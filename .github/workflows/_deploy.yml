name: Deploy

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'The tag to deploy'
        required: true
        type: string
      service:
        description: 'The service to deploy'
        required: true
        type: string
      environment:
        description: 'The environment to deploy to'
        required: true
        type: choice
        options:
          - stage
          - prod
      dry:
        description: 'Whether to run the deployment in dry-run mode'
        required: false
        type: boolean
        default: true

  workflow_call:
    inputs:
      tag:
        description: 'The tag to deploy'
        required: true
        type: string
      service:
        description: 'The service to deploy'
        required: true
        type: string
      environment:
        description: 'The environment to deploy to'
        required: true
        type: string
      dry:
        description: 'Whether to run the deployment in dry-run mode'
        required: false
        type: boolean
        default: false

permissions: {}

defaults:
  run:
    shell: bash

concurrency:
  group: ${{ github.workflow }}-deploy
  cancel-in-progress: true

jobs:
  # The deployment process is repeated for all environments.
  # 1) pull the image from ghcr
  # 2) tag the image with the environment name
  # 3) push the image to the environment's container registry
  # 4) wait for the environment to have the image running
  # 5) run the smoke tests on the environment
  # 6) update the latest image for the environment container registry
  # 7) wait for approval to continue based on the environment protection rules.
  context:
    runs-on: ubuntu-latest
    outputs:
      dry: ${{ steps.context.outputs.dry }}
      environment: ${{ steps.context.outputs.environment }}
      service: ${{ steps.context.outputs.service }}

    steps:
      - uses: actions/checkout@v4

      - name: Context
        id: context
        run: |
          dry="${{ inputs.dry }} "
          environment="${{ inputs.environment }}"
          service="${{ inputs.service }}"

          # On dry run, we don't want to trigger any actual deployment
          # that could trigger manual approval processes.
          if [[ "$dry" == "true" ]]; then
            environment="review"
          fi

          echo "dry=${dry}" >> "$GITHUB_OUTPUT"
          echo "environment=${environment}" >> "$GITHUB_OUTPUT"
          echo "service=${service}" >> "$GITHUB_OUTPUT"
          cat "$GITHUB_OUTPUT"

  deploy:
    needs: context
    runs-on: ubuntu-latest
    environment: ${{ needs.context.outputs.environment }}
    if: ${{ needs.context.outputs.dry == 'false' }}
    outputs:
      pull_tag: ${{ steps.pull_tag.outputs.tag }}
      push_tag: ${{ steps.push_tag.outputs.tag }}
      previous_version: ${{ steps.previous_version.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Previous Version
        id: previous_version
        run: |
          public_url="${{ vars.APP_PUBLIC_URL }}"
          url="${public_url}/__version__"
          version=$(curl -s --max-time 30 ${url} | jq -r '.version // empty' || echo "")
          echo "version=${version}" >> "$GITHUB_OUTPUT"
          cat "$GITHUB_OUTPUT"

      - name: Pull Tag
        id: pull_tag
        uses: ./.github/actions/docker-tag
        with:
          tag: ${{ inputs.tag }}

      - name: Push Tag
        id: push_tag
        uses: ./.github/actions/docker-tag
        with:
          registry: registry.fly.io
          image: ${{ vars.APP_NAME }}
          version: ${{ steps.pull_tag.outputs.version }}

      - name: Login Docker
        uses: ./.github/actions/login-docker
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image
        run: |
          docker pull ${{ steps.pull_tag.outputs.tag }}

      - name: Tag image
        run: |
          docker tag ${{ steps.pull_tag.outputs.tag }} ${{ steps.push_tag.outputs.tag }}

      - name: Setup Flyctl
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Login to Fly
        run: flyctl auth docker
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Push image
        run: |
          docker push ${{ steps.push_tag.outputs.tag }}

      - name: Deploy to Fly
        run: |
          flyctl deploy \
            --config docker/fly-${{ vars.APP_NAME }}.toml \
            --image "${{ steps.push_tag.outputs.tag }}" \
            --env SERVICE_NAME="${{ needs.context.outputs.service }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      - name: Wait for deployment
        timeout-minutes: 10
        run: |
          public_url="${{ vars.APP_PUBLIC_URL }}"
          url="${public_url}/__version__"
          wait_time=10
          waiting=true

          echo "Waiting for deployment to be ready"

          while $waiting; do
            version=$(curl -s --max-time 30 ${url} | jq -r '.version // empty' || echo "")
            if [ "$version" = "${{ steps.push_tag.outputs.version }}" ]; then
              waiting=false
            else
              echo "Version '${version}' does not match '${{ steps.push_tag.outputs.version }}'"
              sleep "${wait_time}"
            fi
          done
          echo "Deployment is ready"

      - name: Run smoke test
        run: |
          echo "Running smoke test"

  rollback:
    needs: [context, deploy]
    runs-on: ubuntu-latest
    if: ${{ always() && needs.deploy.result == 'failure' }}
    steps:
      - name: Should rollback?
        run: |
          public_url="${{ vars.APP_PUBLIC_URL }}"
          url="${public_url}/__version__"
          current_version=$(curl -s ${url} | jq -r '.version // empty' || echo "")
          previous_version="${{ needs.deploy.outputs.previous_version }}"
          push_tag="${{ needs.deploy.outputs.push_tag }}"

          if [[ "$current_version" == "${push_tag}" ]]; then
            echo "Deployed version is failing for some reason"
            echo "========================================"
            echo "To rollback to previous version, trigger a deployment with: "
            echo "- tag=${previous_version}"
            echo "- service=${{ needs.context.outputs.service }}"
            echo "- environment=${{ needs.context.outputs.environment }}"
            echo "- dry=false"
          fi

  approve:
    if: ${{ always() && (needs.context.outputs.dry == 'true' || needs.deploy.result == 'success') }}
    needs: [context, deploy]
    runs-on: ubuntu-latest
    environment: ${{ needs.context.outputs.environment }}
    steps:
      - name: Wait for approval
        run: echo "Waiting for approval"

